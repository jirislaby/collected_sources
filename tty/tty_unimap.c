#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/ioctl.h>
#include <sys/wait.h>

#include <linux/kd.h>
#include <linux/vt.h>

#define LOOPS 1000
#define PROCS 8
#define THREADS 16

static void do_unimap(const char *node)
{
#define COUNT 7936
	static struct unipair entries[COUNT] = {
{ 0xb1cd, 0xf804 }, { 0x86fd, 0x8e54 }, { 0xc6d2, 0x5d64 }, { 0xe149, 0x6ec1 },
{ 0x71d8, 0xaafa }, { 0x24ee, 0xc6e0 }, { 0x360e, 0x9d48 }, { 0x7c38, 0x63b3 },
{ 0x3c3e, 0x3101 }, { 0x0d54, 0x4c8d }, { 0xc0da, 0x9c09 }, { 0x8441, 0x08a2 },
{ 0x0310, 0xd00d }, { 0x1761, 0x823f }, { 0x8ba9, 0x1cd7 }, { 0x9836, 0xc72c },
{ 0xff7d, 0x5bbf }, { 0xdcd2, 0x52cc }, { 0x23a9, 0x9610 }, { 0x176f, 0xb027 },
{ 0x0822, 0xd3da }, { 0x0197, 0x4cdc }, { 0xa42b, 0x4045 }, { 0xc4f4, 0x4e68 },
{ 0x05cc, 0x7063 }, { 0xfc58, 0x9beb }, { 0x8706, 0x2bb8 }, { 0x4b0d, 0x0fd8 },
{ 0x4075, 0x11c5 }, { 0x1f72, 0x0ba9 }, { 0x037f, 0x1c33 }, { 0xcb0a, 0x93b6 },
{ 0x18ef, 0x4b0f }, { 0x06d2, 0x990e }, { 0x4bf3, 0x5a9b }, { 0xee0d, 0xacac },
{ 0xa21a, 0x21ec }, { 0x2f6e, 0x52cb }, { 0x4aad, 0xaca0 }, { 0xe967, 0x1ffe },
{ 0x6d93, 0xca92 }, { 0xc852, 0x4b0f }, { 0xf2d7, 0x73d2 }, { 0x1cbc, 0xa876 },
{ 0x491e, 0x6e6a }, { 0xbbf3, 0x80fb }, { 0x8dbc, 0x2e54 }, { 0x57fa, 0xc658 },
{ 0x97d0, 0x70bc }, { 0x3370, 0xb7b1 }, { 0xf7bd, 0xa19b }, { 0xe72b, 0xe7cd },
{ 0x67ce, 0x01f8 }, { 0x5848, 0xe35f }, { 0x52fc, 0x17b4 }, { 0xe115, 0x3df4 },
{ 0x6979, 0xec7a }, { 0x8f08, 0x0aba }, { 0x8f7d, 0xc923 }, { 0x5f03, 0xc1d0 },
{ 0xa764, 0xde78 }, { 0xc8de, 0xd0c3 }, { 0x1d44, 0x4d51 }, { 0xe0fd, 0xdb70 },
{ 0x990c, 0x1983 }, { 0x5ce6, 0x4d7f }, { 0x45af, 0x805f }, { 0xe71c, 0x716a },
{ 0x24da, 0x0e15 }, { 0xafd8, 0xa8a8 }, { 0xc288, 0x62db }, { 0xb4e9, 0xfbdf },
{ 0x9410, 0x4483 }, { 0xb89f, 0x7d41 }, { 0xcfed, 0xf6ec }, { 0x0dd2, 0xb3fa },
{ 0x573c, 0xa656 }, { 0x7486, 0x7d97 }, { 0x551c, 0x81f1 }, { 0x434e, 0x97dd },
{ 0xdfea, 0x7ae4 }, { 0xf05a, 0x338f }, { 0xd0ae, 0x4a45 }, { 0x17db, 0xa964 },
{ 0xe908, 0xdfb8 }, { 0xf13c, 0x7a4f }, { 0xb7f6, 0xebd9 }, { 0xbc18, 0xe4e4 },
{ 0x21c4, 0x2a59 }, { 0xc9b1, 0x9587 }, { 0xf77a, 0x54f7 }, { 0x146a, 0x5de1 },
{ 0x28c2, 0xf4e5 }, { 0x4060, 0xfe5e }, { 0x00b2, 0x8bcc }, { 0xe3aa, 0x67b5 },
{ 0xb6cf, 0x771a }, { 0x8f0e, 0xae96 }, { 0xc587, 0xad56 }, { 0x5947, 0xa0bd },
{ 0xe3df, 0xe623 }, { 0xff91, 0xbbc4 }, { 0x141f, 0x8830 }, { 0xba28, 0xb655 },
{ 0x8760, 0x151a }, { 0x3437, 0x849a }, { 0x8772, 0x8d57 }, { 0x38df, 0xa339 },
{ 0x9bf5, 0x1eee }, { 0xceab, 0xd662 }, { 0x5bb8, 0x2b0d }, { 0xf67d, 0xf08b },
{ 0xd7ba, 0xf7fb }, { 0x5580, 0x41bf }, { 0x69c7, 0x993d }, { 0x526f, 0x917d },
{ 0x6126, 0x67de }, { 0xc2ff, 0x204c }, { 0xa354, 0x74e7 }, { 0x59ba, 0x1b9f },
{ 0xc6b8, 0xd3ce }, { 0x9e99, 0xb34b }, { 0x0587, 0x24ee }, { 0xbda5, 0xe225 },
{ 0xfa32, 0xc8ad }, { 0x2494, 0x0cc0 }, { 0xe13e, 0x3f3e }, { 0xe620, 0x9580 },
{ 0x9458, 0x5bbc }, { 0xde11, 0x268a }, { 0xa536, 0x632c }, { 0xbb86, 0x4fae },
{ 0xe93f, 0xc8d7 }, { 0xfb75, 0xfc9b }, { 0xf5fd, 0xddd8 }, { 0x9a79, 0x84e7 },
{ 0x9ba7, 0xe427 }, { 0xc5aa, 0x070d }, { 0xeb01, 0xb63f }, { 0x4497, 0xc32d },
{ 0x7e3b, 0x25d1 }, { 0x4a54, 0xf793 }, { 0x834a, 0x230b }, { 0x151d, 0x4e30 },
{ 0xca08, 0x4737 }, { 0xf20d, 0x04b5 }, { 0x084c, 0x5d88 }, { 0xf9ac, 0x08de },
{ 0x7dc0, 0xc1be }, { 0x1934, 0x5db3 }, { 0xaee5, 0x42c8 }, { 0x2fd0, 0x36a5 },
{ 0x6c6f, 0x0246 }, { 0xfec0, 0x2760 }, { 0xf0eb, 0xc862 }, { 0xf90f, 0xf282 },
{ 0x0c1b, 0x91bf }, { 0x64a6, 0xc62c }, { 0x7bd2, 0x4c28 }, { 0xf862, 0xbc61 },
{ 0xcb1e, 0x26c5 }, { 0x0378, 0x6e48 }, { 0xc002, 0x2dd1 }, { 0xe9a3, 0x5e66 },
{ 0xa6f3, 0x51d2 }, { 0x3a0f, 0x1456 }, { 0x47ad, 0x2921 }, { 0x1489, 0x67ac },
{ 0xf0c3, 0x9379 }, { 0xb9fe, 0xe6c3 }, { 0xfac3, 0xc8e7 }, { 0x058a, 0x8006 },
{ 0xa65b, 0x0fc8 }, { 0xa0d9, 0x6683 }, { 0xd689, 0xb0f7 }, { 0xcb89, 0x3fd4 },
{ 0xae2b, 0xfbc7 }, { 0x8369, 0xd7de }, { 0x7d16, 0x7f6c }, { 0x264a, 0x0b02 },
{ 0xedf4, 0x05f4 }, { 0x36c2, 0xafe9 }, { 0xaaa2, 0xba30 }, { 0x3d7f, 0xea30 },
{ 0x36a9, 0xb0ac }, { 0x0d6e, 0x3f5b }, { 0xf06c, 0xf5fe }, { 0x6762, 0xba05 },
{ 0xa5be, 0x3de8 }, { 0x6503, 0xf9f1 }, { 0x27fd, 0x56b1 }, { 0xa40d, 0xb8dc },
{ 0xc44f, 0x00c4 }, { 0xa491, 0x976f }, { 0x10fe, 0xfa55 }, { 0x975c, 0x9e8f },
{ 0xc3df, 0xb002 }, { 0x0d16, 0x475e }, { 0x8bb3, 0x26d3 }, { 0xdebb, 0x7f81 },
{ 0xfbe7, 0x4859 }, { 0x27fc, 0x58b2 }, { 0x98f3, 0x0496 }, { 0x47c4, 0xb682 },
{ 0xa0eb, 0x709d }, { 0x093d, 0x0aa8 }, { 0xb55a, 0x5502 }, { 0x8b98, 0xa781 },
{ 0xb52d, 0xda6b }, { 0x0eb5, 0x1154 }, { 0x6e86, 0x0f4d }, { 0xed82, 0x94d7 },
{ 0x81f6, 0x16a9 }, { 0xd10f, 0xf9c2 }, { 0x9d22, 0x8655 }, { 0x1c3d, 0xebd5 },
{ 0x44a1, 0xa496 }, { 0xb31e, 0x6267 }, { 0x45a2, 0xe52f }, { 0x3a2a, 0x80a1 },
{ 0x855b, 0x1e7b }, { 0x69b1, 0xe9a6 }, { 0xc7ea, 0x4c52 }, { 0xef7d, 0x92f5 },
{ 0x9f87, 0x5e51 }, { 0xe849, 0x1ae2 }, { 0xbf95, 0xfa71 }, { 0x5d59, 0x9dac },
{ 0x7414, 0x4c71 }, { 0x109b, 0x6480 }, { 0xf4c4, 0x1f41 }, { 0x8071, 0x5081 },
{ 0xd73e, 0x2d21 }, { 0x9f42, 0x056e }, { 0xf3e4, 0xfc91 }, { 0xee40, 0xb4bd },
{ 0x7b4f, 0xb6cf }, { 0x4d85, 0xb933 }, { 0x9d9e, 0x00e5 }, { 0x6e84, 0xcbea },
{ 0xb4a2, 0x79d0 }, { 0x61d8, 0xfd36 }, { 0x805d, 0x622b }, { 0x6bc5, 0x9728 },
{ 0x1068, 0x27a3 }, { 0xc73b, 0x9081 }, { 0xe3d8, 0x1708 }, { 0x0063, 0xd18e },
{ 0x0fc1, 0x0265 }, { 0x5994, 0x70e4 }, { 0xf875, 0x7857 }, { 0x3c13, 0x0fdd },
{ 0xcdcd, 0x3e1c }, { 0x32c2, 0x7ac8 }, { 0x0000, 0x0000 }, { 0x0000, 0x0000 },
	};

	static const struct unimapdesc desc = {
		.entry_ct = COUNT,
		.entries = entries,
	};

	int fd = open(node, O_RDWR);
	if (fd < 0)
		err(1, "open(PIO_UNIMAP)");

	if (ioctl(fd, PIO_UNIMAP, &desc) < 0)
		err(1, "ioctl(PIO_UNIMAP)");

	close(fd);
}

static void do_disallocate(const char *node)
{
	int fd = open(node, O_RDWR);
	if (fd < 0)
		err(1, "open(PIO_UNIMAP)");

	if (ioctl(fd, VT_DISALLOCATE, 0) < 0)
		err(1, "ioctl(VT_DISALLOCATE)");

	close(fd);
}

static void clear_kmemleak()
{
#if 0
	int fd = open("/sys/kernel/debug/kmemleak", O_RDWR);
	if (fd < 0)
		err(1, "open(kmemleak)");

	if (write(fd, "clear", 5) <= 0)
		err(1, "write(clear kmemleak)");
	close(fd);
#endif
}

static void dump_kmemleak()
{
	char buf[4096];
	int fd = open("/sys/kernel/debug/kmemleak", O_RDWR);
	if (fd < 0)
		err(1, "open(kmemleak)");

	if (write(fd, "scan", 4) <= 0)
		err(1, "write(scan kmemleak)");

	puts("kmemleak dump");
	puts("=============");
	while (1) {
		ssize_t rd = read(fd, buf, sizeof(buf));
		if (!rd)
			break;
		if (rd < 0)
			err(1, "read(kmemleak)");
		write(STDOUT_FILENO, buf, rd);
	}
	puts("=============");
	close(fd);
}

static void *do_one_thread(void *arg)
{
	static const char node1[] = "/dev/tty34";
	static const char node2[] = "/dev/tty33";
	unsigned int t_no = (unsigned long)arg;
	unsigned int loop, delay;
	void (*work)(const char *) = (t_no % 2) ? do_unimap : do_disallocate;
	const char *work_data = (t_no % 2) ? node1 : node2;
	pid_t pid = getpid();

	srand(pid + 1000 * t_no);

	for (loop = 0; loop < LOOPS; loop++) {
		if (!(loop % 100))
			printf("%u-%u: loop %u\n", pid, t_no, loop);
		delay = rand() % 10000;
		if (delay > 500)
			usleep(delay);

		work(work_data);
	}

	return NULL;
}

static void do_one_proc()
{
	pthread_t threads[THREADS];
	unsigned int t;

	for (t = 0; t < THREADS; t++)
		pthread_create(&threads[t], NULL, do_one_thread, (void *)(unsigned long)t);

	for (t = 0; t < THREADS; t++)
		pthread_join(threads[t], NULL);
}

int main()
{
	unsigned int proc;

	clear_kmemleak();

	for (proc = 0; proc < PROCS; proc++) {
		if (fork())
			continue;

		do_one_proc();
		exit(0);
	}

	puts("waiting");

	for (proc = 0; proc < PROCS; proc++)
		wait(NULL);

	dump_kmemleak();

	return 0;
}

